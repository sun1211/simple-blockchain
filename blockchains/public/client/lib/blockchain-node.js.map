{"version":3,"file":"blockchain-node.js","sourceRoot":"","sources":["../../../src/client/lib/blockchain-node.ts"],"names":[],"mappings":"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","sourcesContent":["import { sha256 } from './cryptography.js';\r\nimport { randomDelay } from '../ui/common.js';\r\n\r\nconst HASH_REQUIREMENT = '0000';\r\n\r\nexport interface Transaction {\r\n  readonly sender: string;\r\n  readonly recipient: string;\r\n  readonly amount: number;\r\n}\r\n\r\nexport interface Block {\r\n  readonly hash: string;\r\n  readonly nonce: number;\r\n  readonly previousHash: string;\r\n  readonly timestamp: number;\r\n  readonly transactions: Transaction[];\r\n}\r\n\r\nexport type WithoutHash<T> = Omit<T, 'hash'>;\r\nexport type NotMinedBlock = Omit<Block, 'hash' | 'nonce'>;\r\n\r\nexport class BlockchainNode {\r\n  private _chain: Block[] = [];\r\n  private _pendingTransactions: Transaction[] = [];\r\n  private _isMining = false;\r\n\r\n  initializeWith(blocks: Block[]): void {\r\n    this._chain = [...blocks ];\r\n  }\r\n\r\n  async initializeWithGenesisBlock(): Promise<void> {\r\n    const genesisBlock = await this.mineBlock({ previousHash: '0', timestamp: Date.now(), transactions: [] });\r\n    this._chain.push(genesisBlock);\r\n  }\r\n\r\n  async mineBlock(block: NotMinedBlock): Promise<Block> {\r\n    this._isMining = true;\r\n    let hash = '';\r\n    let nonce = 0;\r\n\r\n    do {\r\n      hash = await this.calculateHash({ ...block, nonce: ++nonce })\r\n    } while (!hash.startsWith(HASH_REQUIREMENT));\r\n\r\n    this._isMining = false;\r\n    this._pendingTransactions = [];\r\n    return { ...block, hash, nonce };\r\n  }\r\n\r\n  async mineBlockWith(transactions: Transaction[]): Promise<Block> {\r\n    // NOTE: INTRODUCING A RANDOM DELAY FOR DEMO PURPOSES.\r\n    // We want to randomize block's timestamp creation so the node that generates transactions\r\n    // doesn't have an advantage since it's timestamp will always be earlier.\r\n    await randomDelay(500);\r\n\r\n    const block = { previousHash: this.latestBlock.hash, timestamp: Date.now(), transactions };\r\n    return this.mineBlock(block);\r\n  }\r\n\r\n  get isMining(): boolean {\r\n    return this._isMining;\r\n  }\r\n\r\n  get chain(): Block[] {\r\n    return [ ...this._chain ];\r\n  }\r\n\r\n  get chainIsEmpty(): boolean {\r\n    return this._chain.length === 0;\r\n  }\r\n\r\n  get latestBlock(): Block {\r\n    return this._chain[this._chain.length - 1];\r\n  }\r\n\r\n  get pendingTransactions(): Transaction[] {\r\n    return [ ...this._pendingTransactions ];\r\n  }\r\n\r\n  get hasPendingTransactions(): boolean {\r\n    return this.pendingTransactions.length > 0;\r\n  }\r\n\r\n  get noPendingTransactions(): boolean {\r\n    return this.pendingTransactions.length === 0;\r\n  }\r\n\r\n  addTransaction(transaction: Transaction): void {\r\n    this._pendingTransactions.push(transaction);\r\n  }\r\n\r\n  /**\r\n   * Attempts to add a block into the blockchain. The rejected promise carries the reason why the block wasn't added.\r\n   */\r\n  async addBlock(newBlock: Block): Promise<void> {\r\n    const errorMessagePrefix = `⚠️ Block \"${newBlock.hash.substr(0, 8)}\" is rejected`;\r\n\r\n    // Find the block after which the new block should be added.\r\n    const previousBlockIndex = this._chain.findIndex(b => b.hash === newBlock.previousHash);\r\n    if (previousBlockIndex < 0) {\r\n      throw new Error(`${errorMessagePrefix} - there is no block in the chain with the specified previous hash \"${newBlock.previousHash.substr(0, 8)}\".`);\r\n    }\r\n\r\n    // The current node may already have one or more blocks generated (or received from other nodes in the network),\r\n    // after the one we attempt to add. In this case the longest chain takes precedence and the new block is rejected.\r\n    const tail = this._chain.slice(previousBlockIndex + 1);\r\n    if (tail.length >= 1) {\r\n      throw new Error(`${errorMessagePrefix} - the longer tail of the current node takes precedence over the new block.`);\r\n    }\r\n\r\n    // Verify the hash of the new block against the hash of the previous block.\r\n    const newBlockHash = await this.calculateHash(newBlock);\r\n    const prevBlockHash = this._chain[previousBlockIndex].hash;\r\n    const newBlockValid = (\r\n      newBlockHash.startsWith(HASH_REQUIREMENT) &&\r\n      newBlock.previousHash === prevBlockHash &&\r\n      newBlock.hash === newBlockHash\r\n    );\r\n    if (!newBlockValid) {\r\n      throw new Error(`${errorMessagePrefix} - hash verification has failed.`);\r\n    }\r\n\r\n    // Append the new block at the end of the chain.\r\n    this._chain = [ ...this._chain, newBlock ];\r\n  }\r\n\r\n  private async calculateHash(block: WithoutHash<Block>): Promise<string> {\r\n    const data = block.previousHash + block.timestamp + JSON.stringify(block.transactions) + block.nonce;\r\n    return sha256(data);\r\n  }\r\n}\r\n"]}